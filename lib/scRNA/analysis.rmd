---
title: "scRNA Sequencing Data Analysis Report"
date: "`r format(Sys.time())`"
output: 
  rmdformats::readthedown:
    code_folding: hide
    self_contained: true
    thumbnails: false
    lightbox: false    
    toc_depth: 3
    number_sections: true
---

<style type="text/css">
#content {
    max-width: 1500px !important;
    margin-left: 300px !important;
}
#table-of-contents {
    width: 300px !important;
}
.main-container {
  max-width: 90%;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  tidy = TRUE,
  tidy.opts = list(width.cutoff = 120),
  message = FALSE,
  warning = FALSE
)

add_cluster<-function(object, new.cluster.name, new.cluster.ids){
  seurat_clusters<-object[["seurat_clusters"]]$seurat_clusters
  names(new.cluster.ids) <- levels(seurat_clusters)

  new.cluster.values<-plyr::mapvalues(x = seurat_clusters, from = levels(seurat_clusters), to = new.cluster.ids)
  names(new.cluster.values)<-names(seurat_clusters)
  
  object[[new.cluster.name]]<-new.cluster.values
  object
}

run_cluster<-function(object, Remove_Mt_rRNA, rRNApattern, Mtpattern, pca_dims){
  if (Remove_Mt_rRNA) {
    rRNA.genes <- grep(pattern = rRNApattern,  rownames(object), value = TRUE)
    Mt.genes<- grep (pattern= Mtpattern,rownames(object), value=TRUE )
    var.genes <- dplyr::setdiff(VariableFeatures(object), c(rRNA.genes,Mt.genes))
  } else {
    var.genes <- VariableFeatures(object)
  }
  object <- RunPCA(object = object, features = var.genes, verbose=FALSE)
  object <- RunUMAP(object = object, dims=pca_dims, verbose = FALSE)
  #object <- FindNeighbors(object = object, reduction="UMAP", verbose=FALSE)
  object <- FindNeighbors(object = object, dims=pca_dims, verbose=FALSE)
  object <- FindClusters(object=object, verbose=FALSE, random.seed=random.seed, resolution=resolution)

  markers <- FindAllMarkers(object, features=var.genes, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
  markers <- markers[markers$p_val_adj < 0.01,]
  return(list(object=object, markers=markers))
}
```

```{r, child="Functions.Rmd"} 
```

```{r init, echo=FALSE}
library(dplyr)
library(Seurat)
library(knitr)
library(kableExtra)
library(ggplot2)
library(ggpubr)
library(rmdformats)
library(DT)
library(data.table)
library(digest)
library(heatmap3)
library(cowplot)
library(scales)

options_table<-read.table("fileList2.txt", sep="\t", header=F, stringsAsFactors = F)
options<-split(options_table$V1, options_table$V2)

optionstr<-paste0(options_table$V1, collapse = "_")

Mtpattern= options$Mtpattern
rRNApattern=options$rRNApattern
Remove_Mt_rRNA= ifelse(options$Remove_Mt_rRNA == "FALSE", FALSE, TRUE)
resolution=as.numeric(options$resolution)
species=options$species
markerfile<-options$markers_file

nFeature_cutoff_min=as.numeric(options$nFeature_cutoff_min)
nFeature_cutoff_max=as.numeric(options$nFeature_cutoff_max)
nCount_cutoff=as.numeric(options$nCount_cutoff)
mt_cutoff=as.numeric(options$mt_cutoff)

pca_dims<-1:as.numeric(options$pca_dims)

filelist1<-read.table("filelist1.txt", header=F)
filestr<-paste0(filelist1$V1, collapse = "_")

prefix=paste0(options$prefix , "_", digest(paste0(optionstr, filestr), "md5", serialize = FALSE))

rawdata_file = paste0(prefix, "_rawdata.rds")
if(!file.exists(rawdata_file)){
  filelist1<-read.table("filelist1.txt", header=F)
  finalobj<-NULL
  objs<-apply(filelist1, 1, function(x){
    fileName  = x[[1]]
    fileTitle = x[[2]]
    if(dir.exists(fileName)){
      counts = Read10X(fileName)
    } else {
      counts = Read10X_h5(fileName)
    }
    sobj = CreateSeuratObject(counts = counts, project = fileTitle,  min.cells = 3, min.features = 200)
    return(sobj)
  })
  
  if(length(objs) == 1){
    obj <- objs[[1]]
  }else{
    cellids<-unlist(lapply(objs, function(x) x@project.name))
    obj <- merge(objs[[1]], y = unlist(objs[2:length(objs)]), add.cell.ids = cellids, project = "integrated")
  }
  rm(objs)
  
#  obj@assays$RNA@counts@Dimnames[[1]] <- toupper(obj@assays$RNA@counts@Dimnames[[1]])
#  obj@assays$RNA@data@Dimnames[[1]] <- toupper(obj@assays$RNA@data@Dimnames[[1]])
  
  # calculate mitochodram percentage in each sample
  saveRDS(obj, file=rawdata_file)
}else{
  obj=readRDS(rawdata_file)
}
allgenes<-obj@assays$RNA@counts@Dimnames[1]

```

```{r celltypedatabase, echo=FALSE}
marker<-data.frame(fread(markerfile))
hsind<-regexpr(species,marker[,1])
marker_species<-marker[hsind>0 & marker$ubiquitousness.index<0.05,]

##change the gene symbol only keep the first letter capitalize
if (species=="Mm") {
  marker_species$official.gene.symbol<-paste0(substr(marker_species$official.gene.symbol,1,1),substr(tolower(marker_species$official.gene.symbol),2,nchar(marker_species$official.gene.symbol)))
}
##

cellType<-tapply(marker_species$official.gene.symbol,marker_species$cell.type,list)
freq<-sort((table(unlist(cellType)))/length(cellType))
weight<-1+sqrt((max(freq)-freq)/(max(freq)-min(freq)))
################

ORA_celltype<-function(medianexp,cellType){
  ORA_result<-matrix(NA, nrow=length(cellType),ncol=dim(medianexp)[2])
  CTA_result<-matrix(0,nrow=length(cellType),ncol=dim(medianexp)[2])
  exp_z<-scale(medianexp)
  genenames<-rownames(medianexp)   
  for (j in 1: dim(medianexp)[2]){
    clusterexp<-medianexp[,j] 
    clusterexp_z<-exp_z[,j]
    for (i in 1:length(cellType)){
      
      ct_exp<-length(intersect(genenames[clusterexp>0],cellType[[i]]))
      ct_not_exp<-length(cellType[[i]])-ct_exp
      exp_not_ct<-sum(clusterexp>0)-ct_exp
      not_exp_not_ct<-length(clusterexp)-ct_not_exp 
      cont.table<-matrix(c(ct_exp,ct_not_exp,exp_not_ct,not_exp_not_ct),nrow=2)
      ORA_result[i,j]<-fisher.test(cont.table,alternative="greater")$p.value
      ###
      weight_ss<-weight[names(weight)%in%cellType[[i]]]
      ind<-match(names(weight_ss),genenames)
      exp_ss<-clusterexp_z[ind[!is.na(ind)]]
      weight_ss<-weight_ss[!is.na(ind)]
      CTA_result[i,j]<-sum(exp_ss*weight_ss)/(length(exp_ss)^0.3)
    }
  }
  rownames(ORA_result)<-rownames(CTA_result)<-names(cellType)
  minp_ora_ind<- apply(ORA_result,2,function(x){which.min(x)})
  minp_ora<-apply(ORA_result,2,min)
  names(minp_ora)<-rownames(ORA_result)[minp_ora_ind]
  
  max_cta_ind<- apply(CTA_result,2,function(x){which.max(x)})
  max_cta<-apply(CTA_result,2,max,na.rm=T)
  names(max_cta)<-rownames(CTA_result)[max_cta_ind]
  return(list(ora=ORA_result,cta=CTA_result,min_ora=minp_ora,max_cta=max_cta))
}

```
# Quality control

A few QC metrics [commonly used](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4758103/) by the community include

* The number of unique genes detected in each cell. 
    + Low-quality cells or empty droplets will often have very few genes
    + Cell doublets or multiplets may exhibit an aberrantly high gene count
* Similarly, the total number of molecules detected within a cell (correlates strongly with unique genes)
* The percentage of reads that map to the mitochondrial genome
    + Low-quality / dying cells often exhibit extensive mitochondrial contamination
    + We calculate mitochondrial QC metrics with the `PercentageFeatureSet` function, which calculates the percentage of counts originating from a set of features
    + We use the set of all genes starting with either `mt-` or `MT-` as a set of mitochondrial genes

```{r mito, echo=FALSE}
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
obj[["percent.mt"]] <- PercentageFeatureSet(object = obj, pattern = Mtpattern)
```

We visualize QC metrics.

```{r qc2, echo=FALSE, fig.height=6, fig.width=13, fig.cap=figRef("qc_metrics_2", "Scatter plot of number of feature/percentage of mitochondrial vs number of read count")}

# FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.

plot1 <- FeatureScatter(object = obj, feature1 = "nCount_RNA", feature2 = "percent.mt") + geom_hline(yintercept = mt_cutoff, color="black")  + geom_vline(xintercept = nCount_cutoff, color="black")
plot2 <- FeatureScatter(object = obj, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")  + geom_hline(yintercept = c( nFeature_cutoff_min, nFeature_cutoff_max), color="black")  + geom_vline(xintercept = nCount_cutoff, color="black") 
CombinePlots(plots = list(plot1,plot2))

```

# Data filter and cluster analysis 

We use QC metrics to filter cells.

* We filter cells that have unique feature counts less than `r nFeature_cutoff_min` or larger than `r nFeature_cutoff_max` 
* We filter cells that have read count less than `r nCount_cutoff`
* We filter cells that have >`r mt_cutoff`% mitochondrial counts

Then we normalize the data and run non-linear dimensional reduction (UMAP/tSNE).

```{r data_prepartion, echo=FALSE}
random.seed=20191015
cluster_markers_file = paste0(prefix, "_cluster_markers.rds")
if(!file.exists(cluster_markers_file)){
  obj <- subset(obj, subset = nFeature_RNA > nFeature_cutoff_min & nFeature_RNA<nFeature_cutoff_max & nCount_RNA>nCount_cutoff & percent.mt < mt_cutoff)

  obj <- SCTransform(obj, vars.to.regress = "percent.mt", verbose = FALSE)
  obj_markers <- run_cluster(obj, Remove_Mt_rRNA, rRNApattern, Mtpattern, pca_dims)
  saveRDS(obj_markers, file=cluster_markers_file)
}else{
  obj_markers = readRDS(cluster_markers_file)
  if (Remove_Mt_rRNA) {
    var.genes <- dplyr::setdiff(VariableFeatures(obj), c(rRNA.genes,Mt.genes))
  } else {
    var.genes <- VariableFeatures(obj)
  }
}
obj <- obj_markers$object
obj.markers <- obj_markers$markers
```

```{r markers, eval=T, echo=FALSE, results="asis"}
cat("\n\n## Marker genes for each cluster\n\n")

top10 <- obj.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC)
top10marker_file = paste0(prefix, "_top10markers.csv")
write.csv(top10, file=top10marker_file, row.names=F, quote = F)
```

```{r top5table, echo=FALSE, results="asis"}
top5 <- obj.markers %>% group_by(cluster) %>% top_n(n = 5, wt = avg_logFC)
print(kable_styling(kable(top5, caption=tabRef("top5", "Top 5 marker genes in each cluster"))))
```

# Cell clusters
    
```{r qc1, echo=FALSE, fig.height=5, fig.width=13, fig.cap=figRef("qc_metrics_1", "Violin plot of percentage of mitochondrial, number of feature and number of read count")}
p1<-VlnPlot(object = obj, features = c("percent.mt"), label=T)
p2<-VlnPlot(object = obj, features = c("nFeature_RNA"), ncol=1, label=T)
p3<-VlnPlot(object = obj, features = c("nCount_RNA"), ncol=1, label=T)
plot_grid(p1,p2,p3,ncol=3)

```

``` {r umap_cells, echo=FALSE, fig.height=8, fig.width=18, fig.cap=figRef("umap_cells", "UMAP of cells (left) and samples (right)")}
# note that you can set `label = TRUE` or use the LabelClusters function to help label individual clusters
seurat_clusters<-unlist(obj[["seurat_clusters"]])
seurat_colors<-hue_pal()(length(levels(seurat_clusters)))
names(seurat_colors)<-levels(seurat_clusters)
p1<-DimPlot(object = obj, reduction = 'umap', label=TRUE, group.by="seurat_clusters", cols=seurat_colors)
p2<-DimPlot(object = obj, reduction = 'umap', label=FALSE, group.by="orig.ident")
plot_grid(p1,p2)
```

```{r sample_cells_count, echo=FALSE, fig.height=8, fig.width=18, fig.cap=figRef("sample_cells_count", "Percentage of cell from samples in each cluster")}
os<-table(obj$orig.ident, obj$seurat_clusters)
osm<-melt(os)
colnames(osm)<-c("Sample", "Cluster", "Cell")
osm$Cluster<-paste0("Cluster ", osm$Cluster)
osm$Cluster<-factor(osm$Cluster, levels=unique(osm$Cluster))
osm_perc = osm %>% dplyr::group_by(Cluster) %>% dplyr::mutate(Percent = Cell/sum(Cell))

ggplot(osm_perc, aes(x="",y=Percent,fill=Sample)) + geom_bar(stat="identity", width=1) + coord_polar("y", start=0) + facet_wrap(~Cluster) + theme_void()

```

```{r heatmap_samples, echo=FALSE, fig.height=max(10, length(top10$gene) / 10), fig.width=12, fig.cap=figRef("heatmap_samples", "Marker genes in each cell type")}
DoHeatmap(obj, features = top10$gene, group.colors=seurat_colors, angle = 90) + NoLegend()
```

# Predict cell types

```{r}
#obj<-readRDS(cluster_umap_file)
clusters<-obj@active.ident

sumcounts<-t(apply(GetAssayData(obj,assay="RNA",slot="data"),1,function(x){tapply(x,clusters,sum)}))
logsumcounts<-log2(sumcounts+1)
```

```{r gene_expression_prediction_umap, include=(species == "Mm"), eval=(species == "Mm"), fig.width=18, fig.height=8, results="asis"}
library(scUnifrac)
load(system.file("extdata", "ref.expr.Rdata", package = "scUnifrac"))

commongene<-intersect(rownames(logsumcounts),rownames(ref.expr))
sample_data<-logsumcounts[commongene,]
ref_data=ref.expr[commongene,]
combined_data = cbind(sample_data, ref_data)

data.quantileAll <- apply(combined_data, 2, function(x){quantile(x, 0.75)})
data.quantileAll<-data.quantileAll / median(data.quantileAll)

data.norm <- t(t(combined_data) / data.quantileAll)
sample_data.norm<-data.norm[,c(1:ncol(sample_data))]
ref_data.norm<-data.norm[,c((ncol(sample_data)+1):ncol(data.norm))]

preCell<-scUnifrac_predictCelltype(sample_data.norm,ref.expr=ref_data.norm,normalize=F,corcutoff=0.3, drawpicture=F)
cat("\n\n## Cell type prediction using using expression database\n\n")
colCell<-preCell
new.cluster.ids = c()
for(col in c(1:ncol(preCell))){
  maxvalue = max(preCell[,col])
  maxindex = which(preCell[, col]==maxvalue)[1]
  new.cluster.ids=c(new.cluster.ids, rownames(preCell)[maxindex])
  colCell[, col] = ifelse(preCell[, col]==maxvalue, paste("<font color=\"red\">", round(preCell[, col], 2), "</font>"), round(preCell[, col], 2))
}

cat("\n\n\n### Predicted cell types for each cluster\n\n")

obj<-add_cluster(obj, new.cluster.ids, "cell_expression_clusters")

p1<-DimPlot(object = obj, reduction = 'umap', label=TRUE, group.by="seurat_clusters")
p2<-DimPlot(object = obj, reduction = 'umap', label=TRUE, group.by="cell_expression_clusters")
plot_grid(p1,p2)
```

```{r gene_expression_prediction_table, include=(species == "Mm"), eval=(species == "Mm"), results="asis"}
cat("\n\n\n### Cell type prediction correlation table\n\n")
print(kable(colCell, escape = FALSE))
```

```{r gene_expression_prediction_heatmap, include=(species == "Mm"), eval=(species == "Mm"), fig.width=18, fig.height=10, results="asis"}

cat("\n\n\n### Cell type prediction correlation heatmap\n\n")
heatmap3(preCell, scale="none")
```

```{r gene_activity, results="asis"}

cat("\n\n## Cell type prediction using gene activity database\n\n")

data.quantileAll <- apply(logsumcounts, 2, function(x){quantile(x, 0.75)})
data.quantileAll<-data.quantileAll / median(data.quantileAll)

data.norm <- t(t(logsumcounts) / data.quantileAll)
predict_celltype<-ORA_celltype(data.norm,cellType)

obj_markers<-readRDS(cluster_markers_file)
obj <- obj_markers$object

#use the max_cta_score for each cluster
new.cluster.ids<-names(predict_celltype$max_cta)
names(new.cluster.ids) <- levels(obj)
obj[["cellactivity_clusters"]] <- new.cluster.ids[unlist(obj[["seurat_clusters"]])]

clusterDf<-data.frame(seurat=unlist(obj[["seurat_clusters"]]), cellactivity=unlist(obj[["cellactivity_clusters"]]))
clusterDf$seurat_colors<-seurat_colors[clusterDf$seurat]

clusterDf$seurat_cellactivity<-paste0(clusterDf$seurat, " : ", clusterDf$cellactivity)
seurat_cellactivity<-clusterDf$seurat_cellactivity

caCount<-table(clusterDf$cellactivity)
clusterDf$caCount<-caCount[clusterDf$cellactivity]

clusterDf<-clusterDf[order(-clusterDf$caCount, clusterDf$seurat),]
seurat_cellactivity<-factor(seurat_cellactivity, levels=unique(clusterDf$seurat_cellactivity))
seurat_cellactivity_colors<-unique(clusterDf$seurat_colors)
obj[["seurat_cellactivity_clusters"]] <- seurat_cellactivity

```

```{r gene_activity_umap, fig.width=18, fig.height=10, results="asis"}
cat("\n\n### Predicted cell types for each cluster\n\n")
p1<-DimPlot(object = obj, reduction = 'umap', label=T, group.by="seurat_clusters", cols=seurat_colors)
p2<-DimPlot(object = obj, reduction = "umap",label=T, group.by="seurat_cellactivity_clusters", cols=seurat_cellactivity_colors)
plot_grid(p1,p2)
```

```{r gene_activity_heatmap, fig.width=18, fig.height=max(10, length(top10$gene) / 10), results="asis"}
DoHeatmap(obj, features = top10$gene, group.by="seurat_cellactivity_clusters", group.colors=seurat_cellactivity_colors, angle=90) + NoLegend()
```

```{r gene_activity_cta_heatmap, fig.width=18, fig.height=10, results="asis"}
cta_index<-apply(predict_celltype$cta,2,function(x){return(order(x,decreasing=T)[1:2])})
cta_index<-unique(sort(cta_index))
cta_mat<- predict_celltype$cta[cta_index,]
  
ora_index<-apply(predict_celltype$ora,2,function(x){return(order(x,decreasing=F)[1:2])})
ora_index<-unique(sort(ora_index))
ora_mat<- predict_celltype$ora[ora_index,]
ora_mat<--log10(ora_mat)  

cat("\n\n### Predict cell type by cell activity score\n\n")
heatmap3(cta_mat, scale="none")
```

```{r gene_activity_ora_heatmap, fig.width=18, fig.height=10, results="asis"}
cat("\n\n### Predict cell type by over representive analysis\n\n")
heatmap3(ora_mat, scale="none")

```

```{r, child="Details.Rmd", eval=file.exists("Details.Rmd")} 
```

# Project options

```{r options, echo=F}
colnames(options_table)<-c("Value", "Option")
options_table<-options_table[,c("Option", "Value")]
options_table<-options_table[!(options_table$Option %in% c("Mtpattern", "rRNApattern")),]
kable(options_table)
```

