---
title: "scRNA Sequencing Data Analysis Report"
date: "`r format(Sys.time())`"
output: 
  html_document:
    toc: true
    toc_depth: 4
    number_sections: true
---

<style type="text/css">
.main-container {
  max-width: 90%;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  tidy = TRUE,
  tidy.opts = list(width.cutoff = 120),
  message = FALSE,
  warning = FALSE
)
```

```{r, child="Functions.Rmd"} 
```

```{r init, echo=FALSE}
library(dplyr)
library(Seurat)
library(knitr)
library(kableExtra)

rawdata_file = "rawdata.rds"
if(!file.exists(rawdata_file)){
	filelist1<-read.table("filelist1.txt", header=F)
	finalobj<-NULL
	objs<-apply(filelist1, 1, function(x){
		fileName  = x[[1]]
		fileTitle = x[[2]]
		if(dir.exists(fileName)){
			counts = Read10X(fileName)
		} else {
			counts = Read10X_h5(fileName)
		}
		sobj = CreateSeuratObject(counts = counts, project = fileTitle,  min.cells = 3, min.features = 200)
		return(sobj)
	})
	
	if(length(objs) == 1){
		obj <- objs[[1]]
	}else{
		cellids<-unlist(lapply(objs, function(x) x@project.name))
		obj <- merge(objs[[1]], y = unlist(objs[2:length(objs)]), add.cell.ids = cellids, project = "integrated")
	}
	rm(objs)
	
	# calculate mitochodram percentage in each sample
	saveRDS(obj, file=rawdata_file)
}else{
	obj=readRDS(rawdata_file)
}
```

# Data preparation and cluster

## Quality control

A few QC metrics [commonly used](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4758103/) by the community include

* The number of unique genes detected in each cell. 
    + Low-quality cells or empty droplets will often have very few genes
    + Cell doublets or multiplets may exhibit an aberrantly high gene count
* Similarly, the total number of molecules detected within a cell (correlates strongly with unique genes)
* The percentage of reads that map to the mitochondrial genome
    + Low-quality / dying cells often exhibit extensive mitochondrial contamination
    + We calculate mitochondrial QC metrics with the `PercentageFeatureSet` function, which calculates the percentage of counts originating from a set of features
    + We use the set of all genes starting with either `mt-` or `MT-` as a set of mitochondrial genes

```{r mito, echo=FALSE}
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
obj[["percent.mito"]] <- PercentageFeatureSet(object = obj, pattern = "^mt-|^MT-")
```

We visualize QC metrics.
    
```{r qc1, echo=FALSE, fig.height=7, fig.width=13, fig.cap=figRef("qc_metrics_1", "Violin plot of number of feature, number of read count and percentage of mitochondrial")}

#Visualize QC metrics as a violin plot
VlnPlot(object = obj, features = c("nFeature_RNA", "nCount_RNA", "percent.mito"), ncol = 3)
```

```{r qc2, echo=FALSE, fig.height=7, fig.width=13, fig.cap=figRef("qc_metrics_2", "Scatter plot of number of feature/percentage of mitochondrial vs number of read count")}

# FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.

plot1 <- FeatureScatter(object = obj, feature1 = "nCount_RNA", feature2 = "percent.mt") 
plot2 <- FeatureScatter(object = obj, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") 
CombinePlots(plots = list(plot1,plot2))

```

## Data filter and cluster analysis 

We use QC metrics to filter cells.

* We filter cells that have unique feature counts less than 200
* We filter cells that have >20% mitochondrial counts

Then we normalize the data and run non-linear dimensional reduction (UMAP/tSNE).

```{r data_prepartion, echo=FALSE}
resolution=0.5
random.seed=20191015
cluster_umap_file = paste0("cluster_umap.resolution", resolution, ".rds")
if(!file.exists(cluster_umap_file)){
	obj <- subset(x = obj, subset = nFeature_RNA > 200 & percent.mt < 20)
	obj <- SCTransform(obj, vars.to.regress = "percent.mito", verbose = FALSE)

	obj <- RunPCA(object = obj, verbose=FALSE)

	dims<-1:20
	#PCA->UMAP
	obj <- RunUMAP(object = obj, dims=dims, verbose = FALSE)
	
	#PCA->Neightbors->Clusters
	obj <- FindNeighbors(object = obj, dims=dims, verbose=FALSE)
	obj <- FindClusters(object=obj, verbose=FALSE, random.seed=random.seed, resolution=resolution)
	
	saveRDS(obj, file=cluster_umap_file)
}else{
	obj = readRDS(cluster_umap_file)
}

```

``` {r umap_cells, echo=FALSE, fig.height=5, fig.width=7, fig.cap=figRef("umap_cells", "UMAP of cells")}
# note that you can set `label = TRUE` or use the LabelClusters function to help label individual clusters
DimPlot(object = obj, reduction = 'umap', label=TRUE)
```

```{r umap_samples, echo=FALSE, fig.height=5, fig.width=7, fig.cap=figRef("umap_samples", "UMAP of samples")}
DimPlot(object = obj, reduction = 'umap', label=FALSE, group.by="orig.ident")
```

# Cell type identification

## Marker genes for each cluster

```{r markers, echo=FALSE, results="asis"}
allmarker_file = paste0("allmarkers.resolution", resolution, ".rds")
if(!file.exists(allmarker_file)){
	allMarkers <- FindAllMarkers(obj)
	saveRDS(allMarkers, allmarker_file)
}else{
	allMarkers <- readRDS(allmarker_file)
}
top10 <- allMarkers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC)
print(kable_styling(kable(top10, caption=tabRef("top10", "Top 10 marker genes in each cluster"))))
```

## Marker genes figures

```{r markergene figures, echo=FALSE, results="asis", fig.width=10, fig.height=6}
cluster<-"0"
for(cluster in levels(top10$cluster)){
	clusterGenes=top10$gene[top10$cluster==cluster]
	cat("\n\n### Marker genes in cluster ", cluster, "  \n\n")
	gi<-1
	for(gi in c(1,3,5,7,9)){
		curgenes<-clusterGenes[gi:(gi+1)]
		p<-FeaturePlot(obj, curgenes, ncol=2, label=T)	
		print(p)
	}
}

```
